# make

- it's used since the history of Unix to build programs since 1976 - wow
- works on a Makefile which has steps/targets

```text
.DEFAUL_GOAL := build

build: vet
	go build hello.go

vet: fmt
	go vet hello.go

fmt:
	go fmt hello.go
```

- Each target is specified with the command that runs for it, after the colon is the target that should run before it
- in the above example since default=build it will try and walk to build but will see `vet`
- so the sequence would be`
  - `fmt` -> `vet` -> `build`

## types

- each variable which is defined but not initialized will have a value **0** unlike `undefined` in JavaScript
- `const` can only be used for literals, we can't say in code that result of an operations of two variables is const

```golang
const x = 10.3
// valid as x is a literal
const y = math.Remainder(x, 2)

```

> error: math.Remainder(x, 2) (value of type float64) is not constantcompilerInvalidConstInit

### scope

- go variables are block scope, vars declared outside the function at the package level are available throughout
- do they shadow? [[doubts]]
- use shorter variable names if the scope is short like a function but if the variable is added in the package scope then give full name as it should be clear what it's doing

### arrays in Go

- they are not that greatly used, whyyy?
  - since go is a strongly typed language and the type of the array contains the length of the array too
  - which makes it difficult to work with as we can't write code or functions which can operate on any array or perform operations
  - also length needs to be specified while creating an array; fixed length not variable

[//begin]: # "Autogenerated link references for markdown compatibility"
[doubts]: doubts.md "doubts"
[//end]: # "Autogenerated link references"
